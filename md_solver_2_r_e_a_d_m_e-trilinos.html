<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>svMultiPhysics: Trilinos Linear Solver Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">svMultiPhysics
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Trilinos Linear Solver Implementation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md6"></a> Developer guide for the Trilinos-based parallel linear solver used in svMultiPhysics.</p>
<h1><a class="anchor" id="autotoc_md7"></a>
Overview</h1>
<p>This implementation uses the <b><a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a></b> framework (specifically <b>Tpetra</b>, <b>Belos</b>, <b>Ifpack2</b>, and <b>MueLu</b> packages) to solve large-scale sparse linear systems arising from finite element discretizations in parallel MPI environments. For detailed instructions on the <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> built used for this project, please refer to the svMultiPhysics/Docker/ubuntu/dockerfile. The instructions found in the dockerfile can be easily adapted for a Linux&ndash;based installation.</p>
<h1><a class="anchor" id="autotoc_md8"></a>
User guide</h1>
<p>The <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> interface of svMultiPhysics allows users to select linear solvers and preconditioners from the <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> linear algebra package for solving large-scale sparse linear systems. This section describes the solvers and preconditioners available through the interface, using the exact names that can be specified in the input .xml file. The linear solvers available are:</p><ul>
<li><code>GMRES</code>: Generalized Minimal Residual method, a robust and widely used Krylov&ndash;subspace solver suitable for general non-symmetric sparse systems. It is typically used for CFD and FSI applications due to its stability and flexibility.</li>
<li><code>CG</code>: Conjugate Gradient method, designed for symmetric positive-definite systems. Within svMultiPhysics, this method should be used for solving the mesh motion equation in the FSI ALE framework, where the system satisfies these mathematical properties.</li>
<li><code>BiCGS</code>: Bi&ndash;Conjugate Gradient Stabilized, an iterative solver for general non&ndash;symmetric problems. It is often used when GMRES becomes too expensive (e.g., due to memory growth with restart size). The preconditioners available are:</li>
<li><code>trilinos-diagonal</code>: the simplest option, performing a row and column scaling using the inverse square root of the diagonal entries. This preconditioner is inexpensive and can be useful for mildly ill-conditioned systems.</li>
<li><code>trilinos-blockjacobi</code>: applies block-Jacobi scaling using the diagonal block submatrices. This often provides better conditioning than simple diagonal scaling, especially for block-structured systems.</li>
<li><code>trilinos-ilu</code>: computes an Incomplete LU (ILU) factorization within an additive Schwarz framework. The ILU has no additional fill beyond the original sparsity pattern, making it relatively efficient while still improving solver robustness.</li>
<li><code>trilinos-ilut</code>: similar to ILU but with a controlled threshold (set to 1.0e-2) that determines the amount of fill. A higher threshold generates a more accurate (but more expensive) preconditioner. Implemented using the additive Schwarz method.</li>
<li><code>trilinos-riluk0</code>: a reduced ILU(0) factorization with no fill. Implemented with additive Schwarz. It is fast to compute and is typically an excellent choice for FSI problems using velocity&ndash;based structural formulations (<code>ustruct</code> equation for solid).</li>
<li><code>trilinos-riluk1</code>: similar to riluk0 but includes one level of fill, improving accuracy at the cost of additional computation.</li>
<li><code>trilinos-ml</code>: an algebraic multigrid (AMG) preconditioner from the MueLu package. This is generally the preferred choice for displacement&ndash;based structural problems in FSI (<code>struct</code> equation), and it has also proven effective for large&ndash;scale CFD systems. AMG preconditioners can be expensive to build but scale very well for large problems, making them ideal for high-resolution simulations. </li>
</ul>
<h2><a class="anchor" id="autotoc_md9"></a>
Notes on the trilinos-ml</h2>
<p>AMG can be extremely powerful, but only when configured appropriately for the specific PDE, mesh size, and physical model. Because of the large number of tunable parameters and because optimal settings differ between CFD, FSI, and structural mechanics, exposing everything through the standard .xml input file would be cumbersome and hard&ndash;coding problem specific AMG parameters in the source code requires solver rebuilding everytime a change is implemented. Instead, svMultiPhysics allows a dedicated AMG parameters file, letting advanced users:</p><ul>
<li>override defaults (hard&ndash;coded in the solver already) for smoother and coarsening choices</li>
<li>tailor AMG behavior to their problem class</li>
<li>experiment with performance tuning without modifying the main simulation input files This approach keeps the main input format clean while still providing expert&ndash;level control for those who need it. In order to use the AMG parameters from file, a file named exactly <code>mueluOptions.xml</code> must be in the same folder where the simulation input file is. An example <code>mueluOptions.xml</code> file is included in the svMultiPhysics/Code/Source/solver directory.</li>
</ul>
<p><b>Files:</b></p><ul>
<li><code><a class="el" href="trilinos__impl_8h_source.html">trilinos_impl.h</a></code> — type definitions, function declarations, and key data structures</li>
<li><code>trilinos_impl.cpp</code> — implementation of assembly, matrix construction, and solve routines</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md11"></a>
Key Data Structures</h1>
<h2><a class="anchor" id="autotoc_md12"></a>
1. &lt;tt&gt;Trilinos&lt;/tt&gt; Struct</h2>
<p>Central container holding all Tpetra/Trilinos objects for a linear system solve:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code hl_struct" href="struct_trilinos.html">Trilinos</a> {</div>
<div class="line">  Teuchos::RCP&lt;const Tpetra_Map&gt; Map;           <span class="comment">// DOF ownership map (owned nodes only)</span></div>
<div class="line">  Teuchos::RCP&lt;const Tpetra_Map&gt; ghostMap;      <span class="comment">// DOF map including ghost nodes</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_MultiVector&gt; F;           <span class="comment">// RHS vector (owned DOFs)</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_MultiVector&gt; ghostF;      <span class="comment">// RHS vector (owned + ghost DOFs)</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_CrsMatrix&gt; K;             <span class="comment">// Global stiffness matrix</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_Vector&gt; X;                <span class="comment">// Solution vector (owned DOFs)</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_Vector&gt; ghostX;           <span class="comment">// Solution vector (owned + ghost)</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_Import&gt; Importer;         <span class="comment">// Import object (ghost communication)</span></div>
<div class="line">  std::vector&lt;Teuchos::RCP&lt;Tpetra_MultiVector&gt;&gt; bdryVec_list;  <span class="comment">// Coupled Neumann BCs</span></div>
<div class="line">  Teuchos::RCP&lt;const Teuchos::Comm&lt;int&gt;&gt; comm;  <span class="comment">// MPI communicator</span></div>
<div class="line">  Teuchos::RCP&lt;Tpetra_CrsGraph&gt; K_graph;        <span class="comment">// Sparse graph structure</span></div>
<div class="line"> </div>
<div class="line">  Teuchos::RCP&lt;Tpetra_Operator&gt; MueluPrec;      <span class="comment">// MueLu (algebraic multigrid) preconditioner</span></div>
<div class="line">  Teuchos::RCP&lt;Ifpack2_Preconditioner&gt; ifpackPrec;  <span class="comment">// Ifpack2 preconditioner</span></div>
<div class="line">};</div>
<div class="ttc" id="astruct_trilinos_html"><div class="ttname"><a href="struct_trilinos.html">Trilinos</a></div><div class="ttdoc">Initialize all Epetra types we need separate from Fortran.</div><div class="ttdef"><b>Definition</b> trilinos_impl.h:121</div></div>
</div><!-- fragment --><p><b>Ownership model:</b></p><ul>
<li><code>Map</code>: defines distribution of DOFs across MPI ranks (owned DOFs only, non-overlapping).</li>
<li><code>ghostMap</code>: extends <code>Map</code> to include ghost DOFs (nodes shared with neighboring ranks).</li>
<li>Vectors (<code>F</code>, <code>X</code>) use <code>Map</code>; ghost vectors (<code>ghostF</code>, <code>ghostX</code>) use <code>ghostMap</code>.</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md14"></a>
2. Tpetra Type Aliases</h2>
<p>Defined in <code><a class="el" href="trilinos__impl_8h_source.html">trilinos_impl.h</a></code> for clarity and portability:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Alias   </th><th class="markdownTableHeadNone"><a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Tpetra_Map</code>   </td><td class="markdownTableBodyNone"><code>Tpetra::Map&lt;LO, GO, Node&gt;</code>   </td><td class="markdownTableBodyNone">Parallel distribution map    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Tpetra_CrsMatrix</code>   </td><td class="markdownTableBodyNone"><code>Tpetra::CrsMatrix&lt;Scalar_d, LO, GO, Node&gt;</code>   </td><td class="markdownTableBodyNone">Sparse matrix (CSR format)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Tpetra_CrsGraph</code>   </td><td class="markdownTableBodyNone"><code>Tpetra::CrsGraph&lt;LO, GO, Node&gt;</code>   </td><td class="markdownTableBodyNone">Sparse graph (topology)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Tpetra_MultiVector</code>   </td><td class="markdownTableBodyNone"><code>Tpetra::MultiVector&lt;Scalar_d, LO, GO, Node&gt;</code>   </td><td class="markdownTableBodyNone">Multi-vector (RHS, etc.)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Tpetra_Vector</code>   </td><td class="markdownTableBodyNone"><code>Tpetra::Vector&lt;Scalar_d, LO, GO, Node&gt;</code>   </td><td class="markdownTableBodyNone">Single vector (solution)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Tpetra_Operator</code>   </td><td class="markdownTableBodyNone"><code>Tpetra::Operator&lt;Scalar_d, LO, GO, Node&gt;</code>   </td><td class="markdownTableBodyNone">Abstract linear operator    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>Belos_LinearProblem</code>   </td><td class="markdownTableBodyNone"><code>Belos::LinearProblem&lt;...&gt;</code>   </td><td class="markdownTableBodyNone">Belos problem wrapper    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>Belos_SolverFactory</code>   </td><td class="markdownTableBodyNone"><code>Belos::TpetraSolverFactory&lt;...&gt;</code>   </td><td class="markdownTableBodyNone">Creates Belos solvers   </td></tr>
</table>
<p><b>Ordinals:</b></p><ul>
<li><code>LO</code> (local ordinal): <code>int</code> — indices within a rank</li>
<li><code>GO</code> (global ordinal): <code>int</code> — global node/DOF indices across all ranks</li>
<li><code>Node</code>: Kokkos node type (typically default)</li>
</ul>
<hr  />
<h2><a class="anchor" id="autotoc_md16"></a>
3. &lt;tt&gt;TrilinosMatVec&lt;/tt&gt; Operator</h2>
<p>Custom <code>Tpetra::Operator</code> that applies the linear operator:</p>
<p>$$ A x = K x + \sum_i v_i (v_i^T x) $$</p>
<p>where:</p><ul>
<li>$K$ is the global stiffness matrix</li>
<li>$v_i$ are coupled Neumann boundary vectors (rank-1 updates for resistance BCs)</li>
</ul>
<p><b>Purpose:</b> enables efficient matrix-free application of boundary terms without explicitly forming outer products $v_i v_i^T$.</p>
<p><b>Key method:</b> </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code hl_function" href="class_trilinos_mat_vec.html#ab30c05abed8c81e5b21014dec64a0f73">TrilinosMatVec::apply</a>(<span class="keyword">const</span> Tpetra_MultiVector&amp; x, Tpetra_MultiVector&amp; y, ...)</div>
<div class="ttc" id="aclass_trilinos_mat_vec_html_ab30c05abed8c81e5b21014dec64a0f73"><div class="ttname"><a href="class_trilinos_mat_vec.html#ab30c05abed8c81e5b21014dec64a0f73">TrilinosMatVec::apply</a></div><div class="ttdeci">void apply(const Tpetra_MultiVector &amp;X, Tpetra_MultiVector &amp;Y, Teuchos::ETransp mode=Teuchos::NO_TRANS, Scalar_d alpha=Teuchos::ScalarTraits&lt; Scalar_d &gt;::one(), Scalar_d beta=Teuchos::ScalarTraits&lt; Scalar_d &gt;::zero()) const override</div><div class="ttdef"><b>Definition</b> trilinos_impl.cpp:65</div></div>
</div><!-- fragment --><ul>
<li>Computes <code>y = K*x</code> via <code>trilinos_-&gt;K-&gt;apply(...)</code></li>
<li>Adds coupled Neumann contributions: <code>y += v_i * (v_i^T * x)</code> for each boundary vector</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md18"></a>
Workflow</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Phase 1: Initialization and Graph Construction</h2>
<p><b>Function:</b> <code>trilinos_lhs_create(...)</code></p>
<p><b>Inputs:</b></p><ul>
<li><code>numGlobalNodes</code>: total mesh nodes (across all ranks)</li>
<li><code>numLocalNodes</code>: nodes owned by this rank</li>
<li><code>numGhostAndLocalNodes</code>: owned + ghost nodes</li>
<li><code>nnz</code>: number of nonzero entries in CSR node-adjacency structure</li>
<li><code>ltgSorted</code>: local-to-global map (sorted/reordered for better partitioning)</li>
<li><code>ltgUnsorted</code>: local-to-global map (original CSR ordering)</li>
<li><code>rowPtr</code>, <code>colInd</code>: CSR row pointers and column indices (node-level connectivity)</li>
<li><code>Dof</code>: degrees of freedom per node (e.g., 3 for 3D velocity, 4 for velocity+pressure)</li>
</ul>
<p><b>Steps:</b></p>
<ol type="1">
<li><b>Create DOF-based maps:</b><ul>
<li>Expand node GIDs to DOF GIDs: <code>dofGID = nodeGID * dof + d</code></li>
<li>Build <code>Map</code> (owned DOFs) and <code>ghostMap</code> (owned + ghost DOFs)</li>
</ul>
</li>
<li>**Build sparse graph (<code>K_graph</code>):**<ul>
<li>Compute <code>nnzPerDofRow</code>: for each DOF row (using Map ordering), determine number of nonzeros by mapping node GID → unsorted index → <code>rowPtr</code> to get node neighbor count, then multiply by <code>dof</code>.</li>
<li>Construct <code>Tpetra_CrsGraph</code> with pre-allocated <code>nnzPerDofRow</code>.</li>
<li>Insert global column indices via <code>insertGlobalIndices(rowGID, rowCols)</code> for each DOF row.</li>
<li>Call <code>fillComplete()</code> to finalize graph (communication, optimization).</li>
</ul>
</li>
<li><b>Create matrix and vectors:</b><ul>
<li>Matrix <code>K</code> built from finalized graph.</li>
<li>Vectors <code>F</code>, <code>ghostF</code>, <code>X</code>, <code>ghostX</code> created from respective maps.</li>
<li><code>Importer</code> created for ghost node communication (<code>Map</code> → <code>ghostMap</code>).</li>
</ul>
</li>
</ol>
<p><b>Key detail:</b> DOF expansion — node-level CSR connectivity is expanded to DOF-level by iterating over <code>dof × dof</code> blocks per node-node connection.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md21"></a>
Phase 2: Assembly</h2>
<p>Two assembly modes are supported:</p>
<h3><a class="anchor" id="autotoc_md22"></a>
A. Element-by-Element Assembly (Trilinos-native)</h3>
<p><b>Function:</b> <code>trilinos_doassem_(...)</code></p>
<p><b>Inputs:</b></p><ul>
<li><code>numNodesPerElement</code>: nodes in current finite element</li>
<li><code>eqN</code>: element connectivity (local node indices → proc-local indices)</li>
<li><code>lK</code>: element stiffness matrix (dense, size <code>dof*dof × numNodesPerElement × numNodesPerElement</code>)</li>
<li><code>lR</code>: element force vector (size <code>dof × numNodesPerElement</code>)</li>
</ul>
<p><b>Steps:</b></p><ol type="1">
<li>Map element nodes to global node IDs via <code>localToGlobalUnsorted</code>.</li>
<li>For each element node pair <code>(a, b)</code>:<ul>
<li>Compute global row/col DOF indices: <code>rowGID = nodeGID_a * dof + i</code>, <code>colGID = nodeGID_b * dof + j</code>.</li>
<li>Extract block <code>lK[a,b]</code> (size <code>dof × dof</code>).</li>
<li>Call <code>K-&gt;sumIntoGlobalValues(rowGID, dof, vals, cols)</code> to accumulate into global matrix.</li>
</ul>
</li>
<li>Sum force vector entries into <code>ghostF</code> via <code>sumIntoGlobalValue(...)</code>.</li>
</ol>
<p><b>Note:</b> assembly uses <code>ghostF</code> (includes ghost nodes); final communication done later.</p>
<h3><a class="anchor" id="autotoc_md23"></a>
B. Global Assembly (FSILS-assembled)</h3>
<p><b>Function:</b> <code>trilinos_global_solve_(...)</code></p>
<p><b>Inputs:</b></p><ul>
<li><code>Val</code>: preassembled matrix values (CSR format, already assembled by FSILS)</li>
<li><code>RHS</code>: preassembled RHS vector</li>
</ul>
<p><b>Steps:</b></p><ol type="1">
<li>Loop over all nodes (owned + ghost), extract CSR rows from <code>Val</code> and <code>RHS</code>.</li>
<li>Insert/sum values into <code>K</code> and <code>ghostF</code> using global indices.</li>
<li>Proceed to solve (next phase).</li>
</ol>
<p><b>Use case:</b> when matrix/RHS are assembled externally (e.g., legacy FSILS assembly), this path avoids redundant element loops.</p>
<hr  />
<h2><a class="anchor" id="autotoc_md25"></a>
Phase 3: Solve</h2>
<p><b>Function:</b> <code>trilinos_solve_(...)</code></p>
<p><b>Inputs:</b></p><ul>
<li><code>dirW</code>: Dirichlet boundary condition weights (1 for free DOFs, 0 for constrained)</li>
<li>Solver parameters: <code><a class="el" href="classls_type.html" title="Linear system of equations solver type.">lsType</a></code> (GMRES, BiCGStab, CG), <code>relTol</code>, <code>maxIters</code>, <code>kspace</code> (Krylov space size)</li>
<li><code>precondType</code>: preconditioner selection (diagonal, block Jacobi, ILU, ILUT, RILUk, ML)</li>
</ul>
<p><b>Steps:</b></p>
<ol type="1">
<li><b>Finalize matrix:</b><ul>
<li><code>K-&gt;fillComplete()</code> — finalizes parallel assembly (ghost communication, CRS optimization).</li>
</ul>
</li>
<li><b>Export RHS:</b><ul>
<li><code>F-&gt;doExport(*ghostF, exporter, Tpetra::ADD)</code> — sum contributions from ghost nodes to owned nodes (if using element assembly).</li>
<li>Or <code>REPLACE</code> mode if RHS already assembled correctly.</li>
</ul>
</li>
<li><b>Construct Jacobi scaling (diagonal preconditioning + Dirichlet BCs):</b><ul>
<li>Extract diagonal of <code>K</code>.</li>
<li>Modify diagonal: set zero entries to 1, compute <code>D^{-1/2}</code>.</li>
<li>Apply Dirichlet weights from <code>dirW</code>.</li>
<li>Left-scale and right-scale <code>K</code> by diagonal: <code>K ← D^{-1/2} K D^{-1/2}</code>.</li>
<li>Scale <code>F</code> and boundary vectors similarly.</li>
</ul>
</li>
<li><b>Setup Belos linear problem:</b><ul>
<li>Operator: <code><a class="el" href="class_trilinos_mat_vec.html" title="This class implements the pure virtual class Epetra_Operator for the AztecOO iterative solve which on...">TrilinosMatVec</a></code> (applies <code>K</code> + coupled Neumann terms due to resistance or RCR BCs).</li>
<li>Solution: <code>X</code>, RHS: <code>F</code>.</li>
<li>Preconditioner: set via <code>setPreconditioner(...)</code> (creates Ifpack2 or MueLu preconditioner).</li>
</ul>
</li>
<li><b>Create and configure Belos solver:</b><ul>
<li>Solver type: Block GMRES, BiCGStab, or Pseudoblock CG.</li>
<li><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a>: convergence tolerance, max iterations, Krylov space dimension, verbosity.</li>
<li>Factory pattern: <code>Belos::TpetraSolverFactory</code> creates solver manager.</li>
</ul>
</li>
<li><b>Solve:</b><ul>
<li><code>solverManager-&gt;solve()</code> — iterative solve.</li>
<li>Returns convergence status, iteration count, residual norms.</li>
</ul>
</li>
<li><b>Post-process solution:</b><ul>
<li>Unscale <code>X</code> by multiplying with diagonal.</li>
<li>Import solution to ghost nodes: <code>ghostX-&gt;doImport(*X, *Importer, Tpetra::INSERT)</code>.</li>
<li>Copy <code>ghostX</code> to output array <code>x</code>.</li>
</ul>
</li>
<li><b>Cleanup:</b><ul>
<li>Zero out <code>F</code>, <code>ghostF</code>, <code>X</code>, boundary vectors.</li>
<li>Nullify preconditioners and matrix.</li>
</ul>
</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md27"></a>
Preconditioners</h1>
<p>Implemented in <code>setPreconditioner(...)</code>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Preconditioner   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>NO_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">None   </td><td class="markdownTableBodyNone">No preconditioning (may converge slowly)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TRILINOS_DIAGONAL_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">Diagonal   </td><td class="markdownTableBodyNone">Jacobi scaling only (handled separately)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TRILINOS_BLOCK_JACOBI_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">Ifpack2 Jacobi   </td><td class="markdownTableBodyNone">Block Jacobi relaxation (1 sweep)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TRILINOS_ILU_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">Ifpack2 Schwarz+ILU(0)   </td><td class="markdownTableBodyNone">Overlapping domain decomposition with ILU(0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TRILINOS_ILUT_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">Ifpack2 Schwarz+ILUT   </td><td class="markdownTableBodyNone">ILU with threshold dropping    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TRILINOS_RILUK0_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">Ifpack2 RILUK(0)   </td><td class="markdownTableBodyNone">Relaxed ILU (level 0)    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TRILINOS_RILUK1_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">Ifpack2 RILUK(1)   </td><td class="markdownTableBodyNone">Relaxed ILU (level 1)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TRILINOS_ML_PRECONDITIONER</code>   </td><td class="markdownTableBodyNone">MueLu   </td><td class="markdownTableBodyNone">Algebraic multigrid (smoothed aggregation)   </td></tr>
</table>
<p><b>MueLu (ML) preconditioner:</b></p><ul>
<li>Configured in <code>setMueLuPreconditioner(...)</code>.</li>
<li><a class="el" href="class_parameters.html" title="The Parameters class stores parameter values read in from a solver input file.">Parameters</a> tuned for large FSI problems: 6 levels, V-cycle, Gauss-Seidel smoother, KLU coarse solver.</li>
<li>Can load custom parameters from <code>mueluOptions.xml</code> if present.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md29"></a>
Coupled Neumann Boundary Conditions</h1>
<p><b>Motivation:</b> resistance boundary conditions add low-rank updates to the stiffness matrix:</p>
<p>$$ A = K + \sum_i v_i v_i^T $$</p>
<p>where $v_i$ are boundary vectors (normal vectors scaled by resistance coefficients).</p>
<p><b>Implementation:</b></p><ul>
<li>Vectors stored in <code>trilinos_-&gt;bdryVec_list</code> (one per coupled BC face).</li>
<li>Populated in <code>trilinos_bc_create_(...)</code> from user-provided BC data.</li>
<li>Applied during matrix-vector multiply via <code>TrilinosMatVec::apply(...)</code>:<ul>
<li>Compute dot product: $\alpha_i = v_i^T x$</li>
<li>Add contribution: $y \leftarrow y + \alpha_i v_i$</li>
</ul>
</li>
</ul>
<p><b>Advantages:</b></p><ul>
<li>Avoids explicitly forming outer product matrices (memory-intensive).</li>
<li>Efficient vectorized operations.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md31"></a>
Graph and Matrix Construction Details</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
DOF Ordering</h2>
<ul>
<li><b>Node-based CSR:</b> input adjacency (<code>rowPtr</code>, <code>colInd</code>) is node-to-node connectivity.</li>
<li><b>DOF expansion:</b> each node has <code>dof</code> degrees of freedom; global DOF index = <code>nodeGID * dof + d</code>.</li>
<li><b>Map ordering vs CSR ordering:</b><ul>
<li><code>ltgSorted</code>: node ordering used to build Tpetra <code>Map</code> (may differ from CSR order for better partitioning).</li>
<li><code>ltgUnsorted</code>: original CSR ordering.</li>
<li>Graph construction uses a hash map (<code>gidToUnsortedIndex</code>) to map node GID → unsorted index → <code>rowPtr</code> for computing neighbor counts.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Allocation Strategy</h2>
<ul>
<li>Pre-allocate <code>nnzPerDofRow</code> for each DOF row (reduces memory overhead).</li>
<li>For each DOF <code>d</code> of node <code>n</code>:<ul>
<li>Find node's neighbor count: <code>rowPtr[unsortedIdx+1] - rowPtr[unsortedIdx]</code>.</li>
<li>Allocate <code>neighborCount * dof</code> entries (because each node-node connection expands to <code>dof × dof</code> block).</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md35"></a>
Debugging and Diagnostics</h1>
<h2><a class="anchor" id="autotoc_md36"></a>
Matrix/Vector Printing</h2>
<p>Functions available for debugging (write ASCII files):</p><ul>
<li><code>printMatrixToFile(trilinos_)</code> → writes <code>K.txt</code> (global row/col/value triples).</li>
<li><code>printRHSToFile(trilinos_)</code> → writes <code>F.txt</code>.</li>
<li><code>printSolutionToFile(trilinos_)</code> → writes <code>X.txt</code>.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md38"></a>
Solver Types</h1>
<p>Defined in <code><a class="el" href="trilinos__impl_8h_source.html">trilinos_impl.h</a></code>:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Macro   </th><th class="markdownTableHeadNone">Belos Solver   </th><th class="markdownTableHeadNone">Use Case    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TRILINOS_GMRES_SOLVER</code>   </td><td class="markdownTableBodyNone">Block GMRES   </td><td class="markdownTableBodyNone">General nonsymmetric systems (default)    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>TRILINOS_BICGSTAB_SOLVER</code>   </td><td class="markdownTableBodyNone">BiCGStab   </td><td class="markdownTableBodyNone">Faster for some nonsymmetric problems    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>TRILINOS_CG_SOLVER</code>   </td><td class="markdownTableBodyNone">Pseudoblock CG   </td><td class="markdownTableBodyNone">Symmetric positive definite systems   </td></tr>
</table>
<p><b>GMRES parameters:</b></p><ul>
<li><code>kspace</code>: Krylov subspace dimension (typically 50-300).</li>
<li><code>maxRestarts</code>: computed as <code>maxIters / kspace + 1</code>.</li>
<li>Orthogonalization: DGKS (recommended for robustness).</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md40"></a>
Memory Management</h1>
<ul>
<li><b>Reference-counted pointers:</b> all <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> objects use <code>Teuchos::RCP</code> (similar to <code>std::shared_ptr</code>).</li>
<li><b>Cleanup:</b> at end of solve, set <code>K</code>, preconditioners to <code>Teuchos::null</code> to free memory.</li>
<li><b>Kokkos:</b> initialized once (<code>Kokkos::initialize()</code>) and finalized at program exit.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md42"></a>
Integration Points</h1>
<h2><a class="anchor" id="autotoc_md43"></a>
Called from svMultiPhyisics</h2>
<p>Functions bridge C++ <a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> to svMultiPhysics implementation:</p><ul>
<li><code>trilinos_lhs_create(...)</code> — graph/matrix setup (once per timestep/Newton iteration).</li>
<li><code>trilinos_doassem_(...)</code> — default element assembly (called per element).</li>
<li><code>trilinos_global_solve_(...)</code> — solve with pre-assembled data.</li>
<li><code>trilinos_bc_create_(...)</code> — setup coupled Neumann BCs.</li>
</ul>
<h2><a class="anchor" id="autotoc_md44"></a>
TrilinosLinearAlgebra Class</h2>
<p>Higher-level C++ wrapper (<code><a class="el" href="class_trilinos_linear_algebra_1_1_trilinos_impl.html">TrilinosLinearAlgebra::TrilinosImpl</a></code>) provides:</p><ul>
<li><code>alloc(...)</code> — allocate data structures.</li>
<li><code>assemble(...)</code> — element-by-element assembly.</li>
<li><code>solve(...)</code> / <code>solve_assembled(...)</code> — solve linear system.</li>
<li><code>init_dir_and_coup_neu(...)</code> — setup boundary conditions.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md46"></a>
Tips for new development</h1>
<ol type="1">
<li><b>Adding a new preconditioner:</b><ul>
<li>Define a new macro in <code><a class="el" href="trilinos__impl_8h_source.html">trilinos_impl.h</a></code> (e.g., <code>#define TRILINOS_CUSTOM_PREC 709</code>).</li>
<li>Add case in <code>setPreconditioner(...)</code> to configure Ifpack2/MueLu parameters.</li>
<li>If the preconditioner is user&ndash;defined, then it should be implemented as a new Tpetra::Operator class and added to the Belos problem.</li>
</ul>
</li>
<li><b>Changing graph structure:</b><ul>
<li>Graph is fixed after <code>fillComplete()</code>.</li>
<li>To modify: destroy graph (<code>K_graph = Teuchos::null</code>), rebuild in <code>trilinos_lhs_create(...)</code>.</li>
</ul>
</li>
<li><b>Debugging convergence issues:</b><ul>
<li>Enable Belos verbosity: comment out <code>#define NOOUTPUT</code> in <code>trilinos_impl.cpp</code>.</li>
<li>Print matrix/RHS: call <code>printMatrixToFile()</code>, <code>printRHSToFile()</code>.</li>
<li>Check conditioning: ensure diagonal has no zeros (handled by <code>checkDiagonalIsZero()</code>).</li>
<li>To check the sparse pattern of the matrix, consider using hdf5 library. This will allow to save large files that can be read by using a simple Python script</li>
</ul>
</li>
<li><b>Performance profiling:</b><ul>
<li>Use Teuchos::Time for timing sections (example: <code>Belos Solve <a class="el" href="class_timer.html" title="Keep track of time.">Timer</a></code> in code).</li>
<li><a class="el" href="struct_trilinos.html" title="Initialize all Epetra types we need separate from Fortran.">Trilinos</a> has built-in profiling via <code>Teuchos::TimeMonitor</code> (enable with CMake flag).</li>
</ul>
</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md48"></a>
References</h1>
<ul>
<li><a href="https://trilinos.github.io/">Trilinos Documentation</a></li>
<li><a href="https://docs.trilinos.org/dev/packages/tpetra/doc/html/index.html">Tpetra User Guide</a></li>
<li><a href="https://docs.trilinos.org/dev/packages/belos/doc/html/index.html">Belos User Guide</a></li>
<li><a href="https://trilinos.github.io/pdfs/mueluguide.pdf">MueLu User Guide</a></li>
<li><a href="https://docs.trilinos.org/dev/packages/ifpack2/doc/html/index.html">Ifpack2 Documentation</a></li>
</ul>
<hr  />
<p><b>Last updated:</b> November 2025 </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
